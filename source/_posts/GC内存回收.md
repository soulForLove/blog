---
title: GC内存回收
date: 2018-02-24 10:27:09
updated: 2018-02-24 10:27:09
categories: [GC]
tags: [GC,小知识]
description: 在Java中，它的内存管理包括两方面：内存分配（创建Java对象的时候）和内存回收，正因为内存管理完全由JVM负责，所以也使Java很多人不再关心内存分配，导致很多程序低效，耗内存......
copyright: true
comments: true
---
<!-- more -->
## Java在内存中的状态
* 可达状态：在一个对象创建后，有一个以上的引用变量引用它
* 可恢复状态：如果程序中某个对象不再有任何的引用变量引用它，它将先进入可恢复状态。在这个状态下，系统的垃圾回收机制准备回收该对象的所占用的内存，在回收之前，系统会调用finalize()方法进行资源清理，如果资源整理后重新让一个以上引用变量引用该对象，则这个对象会再次变为可达状态；否则就会进入不可达状态
* 不可达状态：当对象的所有关联都被切断，且系统调用finalize()方法进行资源清理后依旧没有使该对象变为可达状态，则这个对象将永久性失去引用并且变成不可达状态，系统才会真正的去回收该对象所占用的资源	

## Java对对象的4种引用
* 强引用 ：创建一个对象并把这个对象直接赋给一个变量，eg ：Person person = new Person("sunny"); 不管系统资源有么的紧张，强引用的对象都绝对不会被回收，即使以后不会再用到
* 软引用 ：通过SoftReference类实现，eg : SoftReference<Person> p = new SoftReference<Person>(new Person("Rain"));,内存非常紧张的时候会被回收，其他时候不会被回收，所以在使用之前要判断是否为null从而判断他是否已经被回收了
* 弱引用 ：通过WeakReference类实现，eg : WeakReference<Person> p = new WeakReference<Person>(new Person("Rain"));不管内存是否足够，系统垃圾回收时必定会回收
* 虚引用 ：不能单独使用，主要是用于追踪对象被垃圾回收的状态。通过PhantomReference类和引用队列ReferenceQueue类联合使用实现

## JAVA辣鸡回收机制
> 内存回收 / 碎片整理

### 辣鸡回收算法
1. 串行回收（单个CPU）/ 并行回收（多个CPU才有用）
```
并行回收的执行效率很高，但复杂度增加，另外也有一些副作用，如内存碎片增加
```

2. 并发执行和应用程序停止
```
***应用程序停止，这种方式会导致应用程序的暂停
***并发执行虽然不会导致应用程序暂停，但是需要解决和应用程序的执行冲突
（应用程序可能在回收阶段修改对象等等），所以并发执行这种方式的系统开销
比应用程序停止更高，而且执行起来需要更多的堆内栈
```
3. 压缩/不压缩/复制
* 支持压缩的垃圾回收器（标记-压缩 = 标记清除+压缩）会把所有的可达对象搬迁到一端，然后直接清理掉端边界以外的内存，减少了内存碎片。
* 不压缩的垃圾回收器（标记-清除）要遍历两次，第一次先从跟开始访问所有可达对象，并将他们标记为可达状态，第二次便利整个内存区域，对未标记可达状态的对象进行回收处理。这种回收方式不压缩，不需要额外内存，但要两次遍历，会产生碎片
* 复制式的垃圾回收器：将堆内存分成两个相同空间，从根（类似于前面的有向图起始顶点）开始访问每一个关联的可达对象，将空间A的全部可达对象复制到空间B，然后一次性回收空间A。对于该算法而言，因为只需访问所有的可达对象，将所有的可达对象复制走之后就直接回收整个空间，完全不用理会不可达对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。

### 堆内存的分代回收
#### 分代回收的依据
1. 对象生存时间的长短：大部分对象在Young期间就被回收
2. 不同代采取不同的垃圾回收策略：新（生存时间短）老（生存时间长）对象之间很少存在引用

#### 堆内存的分代
1. Young代
* 回收机制 ：因为对象数量少，所以采用复制回收
* 回收频率：Young代对象大部分很快进入不可达状态，回收频率高且回收速度快
* 对象来源：绝大多数对象先分配到Eden区，一些大的对象会直接被分配到Old代中
2. Old代
* 回收机制：采用标记压缩算法回收
* 对象来源：对象大直接进入老年代 / Young代中生存时间长的可达对象
* 回收频率 ：因为很少对象会死掉，所以执行频率不高，而且需要较长时间来完成
3. Permanent代 
* 用途 ：用来装载Class，方法等信息，默认为64M，不会被回收
* 对象来源 ：eg：对于像Hibernate，Spring这类喜欢AOP动态生成类的框架，往往会生成大量的动态代理类，因此需要更多的Permanent代内存。所以我们经常在调试Hibernate，Spring的时候经常遇到java.lang.OutOfMemoryError:PermGen space的错误，这就是Permanent代内存耗尽所导致的错误。
* 回收频率 ：不会被回收

### 常见的垃圾回收器

#### 串行回收器（只使用一个CPU）
* Young代采用串行复制算法；Old代使用串行标记压缩算法（三个阶段：标记mark—清除sweep—压缩compact），回收期间程序会产生暂停

#### 并行回收器
* 对Young代采用的算法和串行回收器一样，只是增加了多CPU并行处理； 对Old代的处理和串行回收器完全一样，依旧是单线程

#### 并行压缩回收器
* 对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，其实就是划分不同的区域，然后进行标记压缩算法：
① 将Old代划分成几个固定区域；
② mark阶段（多线程并行），标记可达对象；
③ summary阶段（串行执行），从最左边开始检验知道找到某个达到数值（可达对象密度小）的区域时，此区域及其右边区域进行压缩回收，其左端为密集区域
④ compact阶段（多线程并行），识别出需要装填的区域，多线程并行的把数据复制到这些区域中。经此过程后，Old代一端密集存在大量活动对象，另一端则存在大块空间


#### 并发标识—清理回收（CMS）

* 对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，但归根待地还是标记清理算法：
① 初始标识（程序暂停）：标记被直接引用的对象(一级对象)；
② 并发标识（程序运行）：通过一级对象寻找其他可达对象；
③ 再标记（程序暂停）：多线程并行的重新标记之前可能因为并发而漏掉的对象（简单的说就是防遗漏）
④ 并发清理（程序运行）

### 内存管理小技巧 
1. 尽量使用直接量，eg：String javaStr = “内存回收”
2. 使用StringBuilder和StringBuffer进行字符串连接等操作
3. 尽早释放无用对象
4. 尽量少使用静态变量
5. 缓存常用的对象:可以使用开源的开源缓存实现，eg：OSCache，Ehcache
6. 尽量不使用finalize()方法
7. 在必要的时候可以考虑使用软引用SoftReference