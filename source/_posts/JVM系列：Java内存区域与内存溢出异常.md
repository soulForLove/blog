---
title: JVM系列：Java内存区域与内存溢出异常
date: 2018-03-13 13:23:29
updated: 2018-03-13 13:23:29
categories: [jvm]
tags: [jvm]
description: Java内存区域与内存溢出异常
copyright: true
comments: true
---
<!--more-->
## 运行时数据区域
![JVM运行时的数据区结构](http://otkzd4sua.bkt.clouddn.com/jvm-1.png)
###  程序计数器
* 作用
记录当前线程所执行到的字节码的行号。字节码解释器工作的时候就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
* 意义
JVM的多线程是通过线程轮流切换并分配处理器来实现的，对于我们来说的并行事实上一个处理器也只会执行一条线程中的指令。所以，为了保证各线程指令的安全顺利执行，每条线程都有独立的私有的程序计数器。
* 存储内容
当线程中执行的是一个Java方法时，程序计数器中记录的是正在执行的线程的虚拟机字节码指令的地址。 
当线程中执行的是一个本地方法时，程序计数器中的值为空。
* 可能出现的异常
此内存区域是唯一一个在JVM上不会发生内存溢出异常（OutOfMemoryError）的区域。

### Java虚拟机栈
> **Java内存区常被分为堆内存（Heap）和栈内存（Stack），其中栈内存其实指的就是虚拟机栈，或者说是虚拟机栈中的局部变量表部分**


* 作用
描述Java方法执行的内存模型。每个方法在执行的同时都会开辟一段内存区域用于存放方法运行时所需的数据，成为栈帧，一个栈帧包含如：局部变量表、操作数栈、动态链接、方法出口等信息。
* 意义
JVM是基于栈的，所以**每个方法从调用到执行结束，就对应着一个栈帧在虚拟机栈中入栈和出栈的整个过程。**
* 存储内容
局部变量表（编译期可知的各种基本数据类型、引用类型和指向一条字节码指令的returnAddress类型）、操作数栈、动态链接、方法出口等信息。 
值得注意的是：**局部变量表所需的内存空间在编译期间完成分配。在方法运行的阶段是不会改变局部变量表的大小的**
* 可能出现的异常
**如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。** 
**如果在动态扩展内存的时候无法申请到足够的内存，就会抛出OutOfMemoryError异常。**
### 本地方法栈
**与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行java方法（字节码）服务，而本地方法则为虚拟机所使用的Native方法服务**
###  Java堆
> **Java堆是垃圾收集器管理的主要区域（GC堆），可细分为：新生代，老年代，按空间可细分为：Eden空间，From Survivor空间，To Survivor空间**
* 作用
**所有线程共享一块内存区域，在虚拟机开启的时候创建**
* 意义
 存储对象实例，更好地分配内存。 
 垃圾回收（GC）。堆是垃圾收集器管理的主要区域。更好地回收内存
* 存储内容
存放对象实例，几乎所有的对象实例都在这里进行分配。堆可以处于物理上不连续的内存空间，只要逻辑上是连续的就可以。 
值得注意的是：在JIT编译器等技术的发展下，所有对象都在堆上进行分配已变得不那么绝对。有些对象实例也可以分配在栈中
* 可能出现的异常
实现堆可以是固定大小的，也可以通过设置配置文件设置该为可扩展的。 
如果堆上没有内存进行分配，并无法进行扩展时，将会抛出OutOfMemoryError异常
###  方法区
* 作用 
用于存储运行时常量池、已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
* 意义 
对运行时常量池、常量、静态变量等数据做出了规定。
* 存储内容 
运行时常量池（具有动态性）、已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
* 可能出现的异常 
当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
###  运行时常量池
> 运行时常量池对于Class文件常量池的另一个特征是具备**动态性**，在运行期间也可能将新的常量放入池中，例如String类的intern()

###  直接内存
> JDK1.4中新加入NIO类，引入一种基于通道与缓冲的IO方式，它可以使用Native函数库**直接分配堆外内存**，然后通过一个存储在Java堆中的DirectByteBuffeer对象作为这块内存的引用进行操作。（在一些场景中显著提高性能，因为避免了Java堆和Native堆中来回复制数据）

如果服务器管理员在配置虚拟机参数时，忽略了直接内存，就有可能导致动态扩展时，出现OutOfMemoryError异常
## HotSpot虚拟机对象
###  对象创建
> 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

内存分配的2种方式：
> **选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**

* **指针碰撞**
Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离
* **空闲列表**
Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值
###  对象的内存布局
> 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）

HotSpot虚拟机的对象头包括两部分信息：
* Mark Word 
第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit。
* 类型指针 
对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身
###  对象的访问定位
> 建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象

目前主流的访问方式有使用句柄和直接指针两种：
* 句柄访问
![](http://otkzd4sua.bkt.clouddn.com/20170406152152314.png)
* 直接指针访问
![](http://otkzd4sua.bkt.clouddn.com/20170406152212892.png)
对比优势：
* 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。
* 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。Sun HotSpot虚拟机是使用第二种方式进行对象虚拟机访问的。
## OutOfMemoryError 异常
> 除了程序计数器，其他运行时区域都有可能抛出OutOfMemoryError异常

###  Java堆溢出
* 内存泄露 
查看泄露对象到GC Roots的引用链，定位泄露代码位置。
* 内存溢出 
如果不存在泄露，即内存中的对象确实都还必须活着，检查JVM堆参数（-Xmx与-Xms），调大参数，检查代码是否存在某些对象生命周期过长，持有状态过长的情况，减少程序运行期的内存消耗。
###  虚拟机栈、本地方法栈溢出
HotSpot不区分虚拟机栈和本地方法栈，栈容量只能由-Xss参数设定。
* StackOverFlow：线程申请的栈深度超过允许的最大深度
* OutOfMemoryError： 虚拟机扩展时无法申请到足够的内存空间
StackOverFlow的情况：递归调用方法，定义大量的本地变量，增大此方法帧中本地变量表的长度。
OutOfMemoryError：多线程下的内存溢出，与栈空间是否足够大并不存在任何联系。为每个线程的栈分配的内存越大（参数-Xss），那么可以建立的线程数量就越少，建立线程时就越容易把剩下的内存耗尽，越容易内存溢出。在这种情况下，如果不能减少线程数目或者更换64位虚拟机时，减少最大堆和减少栈容量能够换区更多的线程。
###  方法区和运行时常量池溢出
* 运行时常量池
String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。JDK7的intern()方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用
* 方法区
**方法区用于存放Class的相关信息**，如果运行时产生大量的类去填满方法区，就可能发生方法区的内存溢出。 例如主流框架Spring、Hibernate对大量的类进行增强时，利用CGLib字节码生成动态类；大量JSP或动态JSP(JSP第一次运行时需要编译为Java类）。
###  本机直接内存溢出
Java虚拟机可以通过参数**-XX:MaxDirectMemorySize**设定本机直接内存可用大小，如果不指定，则默认与java堆内存大小相同。JDK中可以通过反射获取Unsafe类(Unsafe的getUnsafe()方法只有启动类加载器Bootstrap才能返回实例)直接操作本机直接内存。通过使用-XX:MaxDirectMemorySize=10M，限制最大可使用的本机直接内存大小为10MB。

